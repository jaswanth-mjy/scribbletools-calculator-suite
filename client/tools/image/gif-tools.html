<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Advanced GIF Tools – Edit, Resize, Reverse, Extract & More Online</title>
  <meta name="description" content="Complete GIF toolkit: resize, reverse, change speed, extract frames, crop, optimize, merge, and create GIFs. Fast, privacy-first, and free. No uploads stored.">
  <meta name="keywords" content="GIF tools, resize GIF, reverse GIF, extract GIF frames, change GIF speed, crop GIF, optimize GIF, merge GIFs, create GIF, online GIF editor, privacy, free GIF tool">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Open Graph for SEO/social -->
  <meta property="og:title" content="Advanced GIF Tools – Edit, Resize, Reverse, Extract & More Online">
  <meta property="og:description" content="Complete GIF toolkit: resize, reverse, change speed, extract frames, crop, optimize, merge, and create GIFs. Fast, privacy-first, and free.">
  <meta property="og:type" content="website">
  <meta property="og:image" content="https://scribbletools.org/assets/og-gif-tools.png">
  <meta property="og:url" content="https://scribbletools.org/tools/image/gif-tools.html">
  <link rel="canonical" href="https://scribbletools.org/tools/image/gif-tools.html">
  
  <!-- Include JSZip for frame extraction -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- Include working GIF libraries -->
  <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.min.js"></script>
  
  <!-- Fallback GIF processing implementation -->
  <script>
    // Simple GIF frame parsing fallback if libraries don't load
    window.gifuct = window.gifuct || {
      parseGIF: function(buffer) {
        console.log('Using fallback GIF parser');
        return { lsd: { width: 400, height: 300 } };
      },
      decompressFrames: function(gif, buildPatch) {
        console.log('Using fallback frame decompression');
        // Return dummy frames for fallback
        return [{
          delay: 1000,
          dims: { width: 400, height: 300, left: 0, top: 0 },
          patch: null
        }];
      }
    };
  </script>
  
  <style>
    .gif-tools-tool body { font-family: 'Poppins', sans-serif; background: #F8F4E8; color: #333; margin: 0; }
    .gif-tools-tool main { display: block; }
    .gif-tools-tool .reduce-size-container { max-width: 900px; margin: 3em auto; background: #fff; border-radius: 1.2em; box-shadow: 0 4px 24px #eae3d5; padding: 2em 1.5em 2.5em 1.5em; }
    .gif-tools-tool .handwritten { font-family: 'Caveat', cursive; }
    .gif-tools-tool .upload-area { border: 3px dashed #D9534F; border-radius: 1em; padding: 3em 2em; text-align: center; margin: 2em 0; background: #FDFBF5; transition: all 0.3s; cursor: pointer; }
    .gif-tools-tool .upload-area:hover { background: #F0F8FF; border-color: #4682B4; }
    .gif-tools-tool .upload-area.dragover { background: #E8F5E8; border-color: #228B22; }
    .gif-tools-tool .upload-icon { font-size: 3em; color: #D9534F; margin-bottom: 1em; }
    .gif-tools-tool .file-input { display: none; }
    .gif-tools-tool .upload-btn { background: #D9534F; color: #fff; border: none; border-radius: 0.5em; padding: 1em 2em; font-weight: 600; cursor: pointer; transition: all 0.2s; }
    .gif-tools-tool .upload-btn:hover { background: #c9302c; }
    .gif-tools-tool .multi-upload-area { border: 2px dashed #4682B4; border-radius: 0.8em; padding: 1.5em; margin: 1em 0; background: #F0F8FF; text-align: center; cursor: pointer; }
    .gif-tools-tool .multi-upload-area:hover { background: #E6F3FF; }
    .gif-tools-tool .size-options { margin: 2em 0; }
    .gif-tools-tool .option-group { margin: 1em 0; }
    .gif-tools-tool .option-label { font-weight: 600; margin-bottom: 0.5em; display: block; }
    .gif-tools-tool .option-select, .gif-tools-tool .option-input { width: 100%; padding: 0.8em; border: 2px solid #EAE3D5; border-radius: 0.5em; font-size: 1em; margin-bottom: 1em; box-sizing: border-box; }
    .gif-tools-tool .option-range { width: 100%; margin: 1em 0; }
    .gif-tools-tool .range-value { display: inline-block; background: #4682B4; color: white; padding: 0.3em 0.8em; border-radius: 0.3em; font-weight: 600; min-width: 3em; text-align: center; }
    .gif-tools-tool .reduce-btn { background: #228B22; color: #fff; border: none; border-radius: 0.5em; padding: 1em 2em; font-weight: 600; cursor: pointer; transition: all 0.2s; width: 100%; font-size: 1.1em; }
    .gif-tools-tool .reduce-btn:hover { background: #1e7e1e; }
    .gif-tools-tool .reduce-btn:disabled { background: #ccc; cursor: not-allowed; }
    .gif-tools-tool .secondary-btn { background: #4682B4; color: #fff; border: none; border-radius: 0.5em; padding: 0.8em 1.5em; font-weight: 600; cursor: pointer; transition: all 0.2s; margin: 0.5em; }
    .gif-tools-tool .secondary-btn:hover { background: #357abd; }
    .gif-tools-tool .result-section { margin-top: 2em; }
    .gif-tools-tool .result-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1em; margin: 1em 0; }
    .gif-tools-tool .result-card { background: #F0F8FF; border: 1px solid #B0C4DE; border-radius: 0.5em; padding: 1em; text-align: center; }
    .gif-tools-tool .result-card h4 { color: #4682B4; margin: 0 0 0.5em 0; }
    .gif-tools-tool .result-card .value { font-size: 1.2em; font-weight: bold; color: #D9534F; }
    .gif-tools-tool .preview-comparison { background: #F0FFF0; border: 1px solid #90EE90; border-radius: 0.5em; padding: 1em; margin: 1em 0; }
    .gif-tools-tool .preview-comparison h4 { color: #228B22; margin: 0 0 0.5em 0; }
    .gif-tools-tool .preview-images { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1em; margin: 1em 0; }
    .gif-tools-tool .preview-container { text-align: center; }
    .gif-tools-tool .preview-image { max-width: 100%; max-height: 200px; border-radius: 0.5em; margin: 0.5em 0; border: 2px solid #ddd; }
    .gif-tools-tool .download-section { background: #F0F8FF; border: 1px solid #B0C4DE; border-radius: 0.5em; padding: 1em; margin: 1em 0; text-align: center; }
    .gif-tools-tool .download-btn { background: #4682B4; color: #fff; border: none; border-radius: 0.5em; padding: 1em 2em; font-weight: 600; cursor: pointer; transition: all 0.2s; margin: 0.5em; }
    .gif-tools-tool .download-btn:hover { background: #357abd; }
    .gif-tools-tool .progress-bar { background: #f0f0f0; border-radius: 0.3em; height: 1.5rem; margin: 0.5em 0; overflow: hidden; position: relative; }
    .gif-tools-tool .progress-fill { background: linear-gradient(90deg, #4CAF50, #45a049); height: 100%; transition: width 0.3s; }
    .gif-tools-tool .progress-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #333; font-weight: 600; font-size: 0.9em; }
    .gif-tools-tool .size-warning { color: #dc2626; font-weight: 500; }
    .gif-tools-tool .size-success { color: #059669; font-weight: 500; }
    .gif-tools-tool .scribble-loader { display: flex; gap: 0.5em; justify-content: center; align-items: center; margin: 2em 0; }
    .gif-tools-tool .scribble-dot { width: 0.8em; height: 0.8em; background: #D9534F; border-radius: 50%; animation: scribble-bounce 1.4s ease-in-out infinite both; }
    .gif-tools-tool .scribble-dot:nth-child(1) { animation-delay: -0.32s; }
    .gif-tools-tool .scribble-dot:nth-child(2) { animation-delay: -0.16s; }
    .gif-tools-tool .scribble-dot:nth-child(3) { animation-delay: 0s; }
    .gif-tools-tool .scribble-dot:nth-child(4) { animation-delay: 0.16s; }
    .gif-tools-tool .scribble-dot:nth-child(5) { animation-delay: 0.32s; }
    .gif-tools-tool .frame-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1em; margin: 1em 0; max-height: 400px; overflow-y: auto; border: 1px solid #ddd; padding: 1em; border-radius: 0.5em; }
    .gif-tools-tool .frame-item { text-align: center; border: 2px solid transparent; border-radius: 0.5em; padding: 0.5em; cursor: pointer; transition: all 0.2s; }
    .gif-tools-tool .frame-item:hover { border-color: #4682B4; background: #F0F8FF; }
    .gif-tools-tool .frame-item.selected { border-color: #D9534F; background: #FFF0F0; }
    .gif-tools-tool .frame-item img { max-width: 100%; height: auto; border-radius: 0.3em; }
    .gif-tools-tool .frame-item .frame-number { font-size: 0.8em; color: #666; margin-top: 0.3em; }
    .gif-tools-tool .crop-controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1em; margin: 1em 0; }
    .gif-tools-tool .canvas-container { position: relative; display: inline-block; margin: 1em 0; }
    .gif-tools-tool .crop-overlay { position: absolute; border: 2px dashed #D9534F; background: rgba(217, 83, 79, 0.1); cursor: move; }
    .gif-tools-tool .resize-handle { position: absolute; width: 10px; height: 10px; background: #D9534F; border: 1px solid #fff; cursor: nw-resize; }
    .gif-tools-tool .tool-tabs { display: flex; flex-wrap: wrap; gap: 0.5em; margin: 1em 0; border-bottom: 2px solid #EAE3D5; }
    .gif-tools-tool .tool-tab { padding: 0.8em 1.5em; border: none; background: transparent; color: #666; font-weight: 600; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.2s; }
    .gif-tools-tool .tool-tab:hover { color: #4682B4; background: #F0F8FF; }
    .gif-tools-tool .tool-tab.active { color: #D9534F; border-bottom-color: #D9534F; background: #FFF0F0; }
    .gif-tools-tool .tool-panel { display: none; margin-top: 1em; }
    .gif-tools-tool .tool-panel.active { display: block; }
    .gif-tools-tool .advanced-options { background: #F8F9FA; border: 1px solid #DEE2E6; border-radius: 0.5em; padding: 1em; margin: 1em 0; }
    .gif-tools-tool .advanced-options h4 { color: #495057; margin: 0 0 1em 0; }
    .gif-tools-tool .quality-indicator { display: inline-block; padding: 0.2em 0.5em; border-radius: 0.3em; font-size: 0.8em; font-weight: 600; }
    .gif-tools-tool .quality-high { background: #D4EDDA; color: #155724; }
    .gif-tools-tool .quality-medium { background: #FFF3CD; color: #856404; }
    .gif-tools-tool .quality-low { background: #F8D7DA; color: #721C24; }
    .gif-tools-tool .example-section { background: #FDFBF5; border: 1px solid #FFEAA7; border-radius: 0.7em; padding: 1.2em; margin: 2em 0; }
    .gif-tools-tool .example-section h3 { color: #4682B4; margin-bottom: 0.5em; }
    .gif-tools-tool .example-gif { max-width: 120px; border-radius: 0.4em; margin: 0.5em; border: 1px solid #eee; }
    .gif-tools-tool .related-links { margin-top: 2em; font-size: 1em; }
    .gif-tools-tool .related-links a { color: #D9534F; text-decoration: underline; margin-right: 1.2em; }
    .gif-tools-tool .related-links a:hover { color: #357abd; }
    .gif-tools-tool .step-list { margin: 1.2em 0 1.2em 1.2em; padding: 0; }
    .gif-tools-tool .step-list li { margin-bottom: 0.7em; }
    .gif-tools-tool .sr-only { position: absolute; left: -10000px; top: auto; width: 1px; height: 1px; overflow: hidden; }
    .gif-tools-tool .error-message { background: #F8D7DA; color: #721C24; border: 1px solid #F5C6CB; border-radius: 0.5em; padding: 1em; margin: 1em 0; }
    .gif-tools-tool .success-message { background: #D4EDDA; color: #155724; border: 1px solid #C3E6CB; border-radius: 0.5em; padding: 1em; margin: 1em 0; }
    .gif-tools-tool .warning-message { background: #FFF3CD; color: #856404; border: 1px solid #FFEAA7; border-radius: 0.5em; padding: 1em; margin: 1em 0; }
    @keyframes scribble-bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }
    @media (max-width: 600px) { 
      .gif-tools-tool .reduce-size-container { padding: 1em 0.5em; } 
      .gif-tools-tool .result-grid { grid-template-columns: 1fr; } 
      .gif-tools-tool .preview-images { grid-template-columns: 1fr; }
      .gif-tools-tool .tool-tabs { flex-direction: column; }
      .gif-tools-tool .crop-controls { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
<main>
  <div class="gif-tools-tool">
    <div class="reduce-size-container">
      <header>
        <h1 style="font-family: 'Caveat', cursive; font-size: 3rem; color: #D9534F; margin-bottom: 1rem;">Advanced GIF Tools</h1>
        <p style="font-size:1.2em; margin-bottom:1em;">Complete GIF toolkit: <strong>resize</strong>, <strong>reverse</strong>, <strong>change speed</strong>, <strong>crop</strong>, <strong>optimize</strong>, <strong>extract frames</strong>, and <strong>create animations</strong>. Fast, privacy-first, and completely free.</p>
      </header>
      
      <nav class="related-links" aria-label="Related image tools">
        <strong>Related:</strong>
        <a href="#image-compressor">Image Compressor</a>
        <a href="#image-converter">Image Converter</a>
        <a href="#video-to-gif">Video to GIF</a>
        <a href="#flip-image">Flip Image</a>
      </nav>
      
      <section aria-labelledby="instructions-title">
        <h2 id="instructions-title" style="margin-top:2em; color:#228B22;">How to Use</h2>
        <ol class="step-list">
          <li><strong>Upload</strong> your GIF(s) by dragging into the box or clicking <b>Choose File</b>.</li>
          <li>Select a <strong>tool</strong> from the tabs (Resize, Effects, Frames, Create, Optimize).</li>
          <li>Adjust settings and preview your changes in real-time.</li>
          <li>Click <strong>Process</strong> to apply changes and download your result.</li>
        </ol>
      </section>
      
      <section class="example-section" aria-labelledby="examples-title">
        <h3 id="examples-title">Features & Capabilities</h3>
        <ul style="margin-top:1em;">
          <li><strong>Smart Resize:</strong> Maintain aspect ratio or stretch to exact dimensions</li>
          <li><strong>Advanced Effects:</strong> Reverse, speed control, brightness, contrast, rotation</li>
          <li><strong>Frame Control:</strong> Extract, delete, reorder, or duplicate specific frames</li>
          <li><strong>GIF Creation:</strong> Build animations from multiple images</li>
          <li><strong>Optimization:</strong> Reduce file size with quality controls</li>
          <li><strong>Crop Tool:</strong> Interactive cropping with live preview</li>
          <li>All processing happens locally in your browser for complete privacy</li>
        </ul>
      </section>
      
      <section aria-labelledby="privacy-title">
        <h2 id="privacy-title" style="color:#D9534F;">Privacy Notice</h2>
        <div style="background: #FFF3CD; border: 1px solid #FFEAA7; border-radius: 0.5em; padding: 1em; margin: 1em 0; font-size: 0.95em; color: #856404;">
          <strong>🔒 Complete privacy guaranteed. All processing happens in your browser. No files are uploaded to servers or stored anywhere.</strong>
        </div>
      </section>
      
      <section aria-labelledby="gif-tools-title">
        <h2 id="gif-tools-title" class="sr-only">GIF Tools Interface</h2>
        
        <!-- Upload Area -->
        <div class="upload-area" id="upload-area" tabindex="0" aria-label="Upload GIF area. Drag and drop or click to select GIF files.">
          <div class="upload-icon" aria-hidden="true">🎬</div>
          <h3>Drag & Drop your GIF(s) here</h3>
          <p>or click to browse files</p>
          <input type="file" id="file-input" class="file-input" accept="image/gif" multiple aria-label="Choose GIF files">
          <button class="upload-btn" id="choose-file-btn" style="display:block; margin: 0 auto 1.5em auto;" aria-label="Choose Files">Choose Files</button>
          
          <div id="upload-progress" style="display:none;">
            <div class="progress-bar">
              <div class="progress-fill" id="progress-fill"></div>
              <div class="progress-text" id="progress-text">Processing: 0%</div>
            </div>
          </div>
        </div>
        
        <!-- Tool Selection -->
        <div id="tool-interface" style="display: none;">
          <div class="tool-tabs">
            <button class="tool-tab active" data-tool="resize">📏 Resize</button>
            <button class="tool-tab" data-tool="effects">✨ Effects</button>
            <button class="tool-tab" data-tool="frames">🎞️ Frames</button>
            <button class="tool-tab" data-tool="create">🎨 Create</button>
            <button class="tool-tab" data-tool="optimize">⚡ Optimize</button>
            <button class="tool-tab" data-tool="crop">✂️ Crop</button>
          </div>
          
          <!-- Current GIF Preview -->
          <div class="option-group">
            <label class="option-label">Current GIF:</label>
            <div id="current-preview" style="text-align:center; margin: 1em 0;"></div>
            <div id="gif-info" style="text-align:center; color: #666; font-size: 0.9em;"></div>
          </div>
          
          <!-- Resize Tool -->
          <div class="tool-panel active" id="resize-panel">
            <h3 style="color: #4682B4;">Resize Options</h3>
            <div class="crop-controls">
              <div class="option-group">
                <label class="option-label" for="resize-width">Width (px):</label>
                <input type="number" id="resize-width" class="option-input" placeholder="Auto" min="1" max="2000">
              </div>
              <div class="option-group">
                <label class="option-label" for="resize-height">Height (px):</label>
                <input type="number" id="resize-height" class="option-input" placeholder="Auto" min="1" max="2000">
              </div>
            </div>
            <div class="option-group">
              <label class="option-label">
                <input type="checkbox" id="maintain-aspect" checked> Maintain aspect ratio
              </label>
            </div>
            <div class="option-group">
              <label class="option-label" for="resize-algorithm">Resize Algorithm:</label>
              <select id="resize-algorithm" class="option-select">
                <option value="smooth">Smooth (Best Quality)</option>
                <option value="pixelated">Pixelated (Crisp Edges)</option>
                <option value="fast">Fast (Lower Quality)</option>
              </select>
            </div>
          </div>
          
          <!-- Effects Tool -->
          <div class="tool-panel" id="effects-panel">
            <h3 style="color: #4682B4;">Effects & Transformations</h3>
            <div class="option-group">
              <label class="option-label" for="effect-type">Effect Type:</label>
              <select id="effect-type" class="option-select">
                <option value="none">None</option>
                <option value="reverse">Reverse Animation</option>
                <option value="speed">Change Speed</option>
                <option value="brightness">Adjust Brightness</option>
                <option value="contrast">Adjust Contrast</option>
                <option value="rotate">Rotate</option>
                <option value="flip">Flip</option>
                <option value="grayscale">Grayscale</option>
                <option value="sepia">Sepia Tone</option>
              </select>
            </div>
            
            <div id="speed-controls" style="display:none;">
              <label class="option-label">Speed Multiplier: <span class="range-value" id="speed-value">1.0x</span></label>
              <input type="range" id="speed-slider" class="option-range" min="0.1" max="5" step="0.1" value="1">
            </div>
            
            <div id="brightness-controls" style="display:none;">
              <label class="option-label">Brightness: <span class="range-value" id="brightness-value">0</span></label>
              <input type="range" id="brightness-slider" class="option-range" min="-100" max="100" step="1" value="0">
            </div>
            
            <div id="contrast-controls" style="display:none;">
              <label class="option-label">Contrast: <span class="range-value" id="contrast-value">0</span></label>
              <input type="range" id="contrast-slider" class="option-range" min="-100" max="100" step="1" value="0">
            </div>
            
            <div id="rotate-controls" style="display:none;">
              <label class="option-label">Rotation Angle: <span class="range-value" id="rotate-value">0°</span></label>
              <input type="range" id="rotate-slider" class="option-range" min="0" max="360" step="15" value="0">
            </div>
            
            <div id="flip-controls" style="display:none;">
              <div class="crop-controls">
                <label class="option-label"><input type="checkbox" id="flip-horizontal"> Flip Horizontal</label>
                <label class="option-label"><input type="checkbox" id="flip-vertical"> Flip Vertical</label>
              </div>
            </div>
          </div>
          
          <!-- Frames Tool -->
          <div class="tool-panel" id="frames-panel">
            <h3 style="color: #4682B4;">Frame Management</h3>
            <div class="option-group">
              <label class="option-label" for="frame-action">Action:</label>
              <select id="frame-action" class="option-select">
                <option value="extract">Extract All Frames</option>
                <option value="select">Select Specific Frames</option>
                <option value="delete">Delete Frames</option>
                <option value="duplicate">Duplicate Frames</option>
                <option value="reorder">Reorder Frames</option>
              </select>
            </div>
            <div id="frame-grid-container" style="display:none;">
              <p style="margin: 1em 0; color: #666;">Click frames to select/deselect them:</p>
              <div id="frame-grid" class="frame-grid"></div>
              <div style="margin: 1em 0;">
                <button class="secondary-btn" id="select-all-frames">Select All</button>
                <button class="secondary-btn" id="deselect-all-frames">Deselect All</button>
              </div>
            </div>
          </div>
          
          <!-- Create Tool -->
          <div class="tool-panel" id="create-panel">
            <h3 style="color: #4682B4;">Create GIF from Images</h3>
            <div class="multi-upload-area" id="image-upload-area">
              <div style="font-size: 2em; margin-bottom: 0.5em;">🖼️</div>
              <p>Drop multiple images here to create a GIF</p>
              <input type="file" id="image-input" class="file-input" accept="image/*" multiple>
              <button class="secondary-btn" onclick="document.getElementById('image-input').click()">Choose Images</button>
            </div>
            <div id="image-preview-grid" style="display:none;" class="frame-grid"></div>
            <div class="crop-controls">
              <div class="option-group">
                <label class="option-label" for="frame-delay">Frame Duration (ms):</label>
                <input type="number" id="frame-delay" class="option-input" value="500" min="50" max="5000">
              </div>
              <div class="option-group">
                <label class="option-label" for="loop-count">Loop Count:</label>
                <select id="loop-count" class="option-select">
                  <option value="0">Infinite</option>
                  <option value="1">Once</option>
                  <option value="3">3 times</option>
                  <option value="5">5 times</option>
                  <option value="10">10 times</option>
                </select>
              </div>
            </div>
          </div>
          
          <!-- Optimize Tool -->
          <div class="tool-panel" id="optimize-panel">
            <h3 style="color: #4682B4;">Optimization Settings</h3>
            <div class="option-group">
              <label class="option-label">Quality Level: <span class="range-value" id="quality-value">80</span> <span id="quality-indicator" class="quality-indicator quality-high">High Quality</span></label>
              <input type="range" id="quality-slider" class="option-range" min="1" max="100" step="1" value="80">
            </div>
            <div class="option-group">
              <label class="option-label">Color Reduction: <span class="range-value" id="colors-value">256</span></label>
              <input type="range" id="colors-slider" class="option-range" min="8" max="256" step="8" value="256">
            </div>
            <div class="advanced-options">
              <h4>Advanced Options</h4>
              <label class="option-label"><input type="checkbox" id="dither"> Apply dithering (smoother gradients)</label>
              <label class="option-label"><input type="checkbox" id="optimize-frames"> Optimize frame differences</label>
              <label class="option-label"><input type="checkbox" id="remove-duplicates"> Remove duplicate frames</label>
            </div>
          </div>
          
          <!-- Crop Tool -->
          <div class="tool-panel" id="crop-panel">
            <h3 style="color: #4682B4;">Crop GIF</h3>
            <div id="crop-canvas-container" style="text-align: center; margin: 1em 0;">
              <canvas id="crop-canvas" style="border: 1px solid #ddd; max-width: 100%;"></canvas>
            </div>
            <div class="crop-controls">
              <div class="option-group">
                <label class="option-label" for="crop-x">X Position:</label>
                <input type="number" id="crop-x" class="option-input" value="0" min="0">
              </div>
              <div class="option-group">
                <label class="option-label" for="crop-y">Y Position:</label>
                <input type="number" id="crop-y" class="option-input" value="0" min="0">
              </div>
              <div class="option-group">
                <label class="option-label" for="crop-width">Crop Width:</label>
                <input type="number" id="crop-width" class="option-input" value="100" min="1">
              </div>
              <div class="option-group">
                <label class="option-label" for="crop-height">Crop Height:</label>
                <input type="number" id="crop-height" class="option-input" value="100" min="1">
              </div>
            </div>
            <button class="secondary-btn" id="reset-crop">Reset Crop Area</button>
          </div>
          
          <!-- Process Button -->
          <button class="reduce-btn" id="process-btn" aria-label="Process GIF">🚀 Process GIF</button>
          <button class="secondary-btn" id="reset-btn" aria-label="Reset All">🔄 Reset & Upload New</button>
        </div>
        
        <!-- Results Section -->
        <div id="result-section" style="display: none;">
          <div id="result-grid"></div>
          <div id="preview-comparison"></div>
          <div id="download-section"></div>
        </div>
        
        <!-- Loading Animation -->
        <div id="loading-animation" style="display: none;">
          <div class="scribble-loader">
            <div class="scribble-dot"></div>
            <div class="scribble-dot"></div>
            <div class="scribble-dot"></div>
            <div class="scribble-dot"></div>
            <div class="scribble-dot"></div>
          </div>
          <p style="text-align: center; margin-top: 1em; color: #666;">Processing your GIF...</p>
        </div>
      </section>
    </div>
  </div>
</main>

<script>
// Advanced GIF Tools - Complete Rewrite
(function() {
  'use strict';
  
  // State management
  let currentGif = null;
  let currentFrames = [];
  let selectedFrames = new Set();
  let uploadedImages = [];
  let cropSelection = { x: 0, y: 0, width: 100, height: 100 };
  let isProcessing = false;
  
  // Global initialization function for main app integration
  window.initializeGifTools = function() {
    console.log('🔧 Initializing Advanced GIF Tools...');
    reset();
    init();
  };

  function reset() {
    currentGif = null;
    currentFrames = [];
    selectedFrames.clear();
    uploadedImages = [];
    isProcessing = false;
    
    // Reset UI
    document.getElementById('tool-interface').style.display = 'none';
    document.getElementById('result-section').style.display = 'none';
    document.getElementById('loading-animation').style.display = 'none';
    document.getElementById('file-input').value = '';
    document.getElementById('image-input').value = '';
    
    // Reset all form inputs
    document.querySelectorAll('.option-input').forEach(input => {
      if (input.type === 'number') input.value = '';
      if (input.type === 'checkbox') input.checked = false;
    });
    
    // Reset sliders to default
    document.getElementById('speed-slider').value = '1';
    document.getElementById('brightness-slider').value = '0';
    document.getElementById('contrast-slider').value = '0';
    document.getElementById('rotate-slider').value = '0';
    document.getElementById('quality-slider').value = '80';
    document.getElementById('colors-slider').value = '256';
    
    updateRangeValues();
  }

  function init() {
    console.log('Setting up Advanced GIF Tools...');
    
    // Check library availability
    console.log('Library status:');
    console.log('- JSZip:', typeof JSZip !== 'undefined' ? 'Available' : 'Missing');
    console.log('- GIF:', typeof GIF !== 'undefined' ? 'Available' : 'Missing');
    console.log('- gifuct:', typeof gifuct !== 'undefined' ? 'Available' : 'Missing (will use fallback)');
    
    try {
      setupUploadHandlers();
      setupToolTabs();
      setupEffectControls();
      setupFrameControls();
      setupCreateControls();
      setupOptimizeControls();
      setupCropControls();
      setupProcessButton();
      setupRangeSliders();
      
      console.log('✅ Advanced GIF Tools initialized successfully');
    } catch (error) {
      console.error('❌ Error initializing GIF Tools:', error);
    }
  }

  function setupUploadHandlers() {
    const uploadArea = document.getElementById('upload-area');
    const fileInput = document.getElementById('file-input');
    const chooseBtn = document.getElementById('choose-file-btn');

    chooseBtn.onclick = () => fileInput.click();
    uploadArea.onclick = (e) => {
      if (e.target === uploadArea) fileInput.click();
    };

    uploadArea.ondragover = (e) => {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    };

    uploadArea.ondragleave = () => {
      uploadArea.classList.remove('dragover');
    };

    uploadArea.ondrop = (e) => {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      handleFiles(e.dataTransfer.files);
    };

    fileInput.onchange = (e) => {
      handleFiles(e.target.files);
    };

    uploadArea.onkeydown = (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        fileInput.click();
      }
    };
  }

  function setupToolTabs() {
    document.querySelectorAll('.tool-tab').forEach(tab => {
      tab.onclick = () => switchTool(tab.dataset.tool);
    });
  }

  function switchTool(toolName) {
    // Update tab appearance
    document.querySelectorAll('.tool-tab').forEach(tab => {
      tab.classList.toggle('active', tab.dataset.tool === toolName);
    });

    // Show/hide panels
    document.querySelectorAll('.tool-panel').forEach(panel => {
      panel.classList.toggle('active', panel.id === `${toolName}-panel`);
    });

    // Tool-specific setup
    if (toolName === 'frames' && currentFrames.length > 0) {
      renderFrameGrid();
    } else if (toolName === 'frames' && currentFrames.length === 0) {
      // Show message to upload GIF first
      const grid = document.getElementById('frame-grid');
      grid.innerHTML = '<p style="text-align: center; color: #666; padding: 2em;">Please upload a GIF first to see frames.</p>';
    } else if (toolName === 'crop' && currentGif) {
      setupCropCanvas();
    }
  }

  function setupEffectControls() {
    const effectType = document.getElementById('effect-type');
    effectType.onchange = () => {
      // Hide all effect controls
      document.querySelectorAll('[id$="-controls"]').forEach(el => {
        el.style.display = 'none';
      });

      // Show relevant controls
      const selectedEffect = effectType.value;
      if (['speed', 'brightness', 'contrast', 'rotate', 'flip'].includes(selectedEffect)) {
        document.getElementById(`${selectedEffect}-controls`).style.display = 'block';
      }
    };
  }

  function setupFrameControls() {
    const frameAction = document.getElementById('frame-action');
    frameAction.onchange = () => {
      const container = document.getElementById('frame-grid-container');
      container.style.display = ['select', 'delete', 'duplicate', 'reorder'].includes(frameAction.value) ? 'block' : 'none';
      
      if (frameAction.value !== 'extract') {
        renderFrameGrid();
      }
    };

    document.getElementById('select-all-frames').onclick = () => {
      selectedFrames.clear();
      currentFrames.forEach((_, i) => selectedFrames.add(i));
      updateFrameSelection();
    };

    document.getElementById('deselect-all-frames').onclick = () => {
      selectedFrames.clear();
      updateFrameSelection();
    };
  }

  function setupCreateControls() {
    const imageInput = document.getElementById('image-input');
    const uploadArea = document.getElementById('image-upload-area');

    uploadArea.onclick = () => imageInput.click();
    uploadArea.ondragover = (e) => {
      e.preventDefault();
      uploadArea.style.background = '#E6F3FF';
    };
    uploadArea.ondragleave = () => {
      uploadArea.style.background = '#F0F8FF';
    };
    uploadArea.ondrop = (e) => {
      e.preventDefault();
      uploadArea.style.background = '#F0F8FF';
      handleImageFiles(e.dataTransfer.files);
    };

    imageInput.onchange = (e) => {
      handleImageFiles(e.target.files);
    };
  }

  function setupOptimizeControls() {
    const qualitySlider = document.getElementById('quality-slider');
    qualitySlider.oninput = () => {
      const value = parseInt(qualitySlider.value);
      const indicator = document.getElementById('quality-indicator');
      
      if (value >= 70) {
        indicator.textContent = 'High Quality';
        indicator.className = 'quality-indicator quality-high';
      } else if (value >= 40) {
        indicator.textContent = 'Medium Quality';
        indicator.className = 'quality-indicator quality-medium';
      } else {
        indicator.textContent = 'Low Quality';
        indicator.className = 'quality-indicator quality-low';
      }
    };
  }

  function setupCropControls() {
    const resetBtn = document.getElementById('reset-crop');
    resetBtn.onclick = () => {
      if (currentGif) {
        const img = new Image();
        img.onload = () => {
          cropSelection = { x: 0, y: 0, width: img.naturalWidth, height: img.naturalHeight };
          updateCropInputs();
          setupCropCanvas();
        };
        img.src = URL.createObjectURL(currentGif);
      }
    };

    // Update crop selection when inputs change
    ['crop-x', 'crop-y', 'crop-width', 'crop-height'].forEach(id => {
      document.getElementById(id).onchange = updateCropFromInputs;
    });
  }

  function setupProcessButton() {
    document.getElementById('process-btn').onclick = processGif;
    document.getElementById('reset-btn').onclick = reset;
  }

  function setupRangeSliders() {
    const sliders = [
      'speed-slider', 'brightness-slider', 'contrast-slider', 
      'rotate-slider', 'quality-slider', 'colors-slider'
    ];

    sliders.forEach(id => {
      const slider = document.getElementById(id);
      slider.oninput = updateRangeValues;
    });

    updateRangeValues();
  }

  function updateRangeValues() {
    const updates = {
      'speed-slider': 'speed-value',
      'brightness-slider': 'brightness-value', 
      'contrast-slider': 'contrast-value',
      'rotate-slider': 'rotate-value',
      'quality-slider': 'quality-value',
      'colors-slider': 'colors-value'
    };

    Object.entries(updates).forEach(([sliderId, valueId]) => {
      const slider = document.getElementById(sliderId);
      const valueEl = document.getElementById(valueId);
      if (slider && valueEl) {
        let value = slider.value;
        if (sliderId === 'speed-slider') value += 'x';
        if (sliderId === 'rotate-slider') value += '°';
        valueEl.textContent = value;
      }
    });
  }

  async function handleFiles(files) {
    if (files.length === 0) return;
    
    const file = files[0];
    if (!file.type.includes('gif')) {
      showError('Please select a GIF file.');
      return;
    }

    if (file.size > 50 * 1024 * 1024) {
      showError('File size must be less than 50MB.');
      return;
    }

    showProgress();
    
    try {
      await loadGif(file);
      await loadGifFrames(file); // Ensure frames are loaded
      showSuccess('GIF loaded successfully!');
      document.getElementById('tool-interface').style.display = 'block';
    } catch (error) {
      showError('Error loading GIF: ' + error.message);
    } finally {
      hideProgress();
    }
  }

  async function loadGif(file) {
    currentGif = file;
    
    // Create preview
    const preview = document.getElementById('current-preview');
    const img = document.createElement('img');
    img.src = URL.createObjectURL(file);
    img.style.maxWidth = '300px';
    img.style.maxHeight = '200px';
    img.style.borderRadius = '0.5em';
    preview.innerHTML = '';
    preview.appendChild(img);

    // Show file info and get actual dimensions
    return new Promise((resolve, reject) => {
      img.onload = () => {
        const info = document.getElementById('gif-info');
        info.innerHTML = `
          <strong>Size:</strong> ${(file.size / 1024).toFixed(1)} KB | 
          <strong>Dimensions:</strong> ${img.naturalWidth} × ${img.naturalHeight}px | 
          <strong>Type:</strong> ${file.type} | 
          <strong>Name:</strong> ${file.name}
        `;
        
        // Initialize crop selection with actual dimensions
        cropSelection = { 
          x: 0, 
          y: 0, 
          width: Math.min(img.naturalWidth, 200), 
          height: Math.min(img.naturalHeight, 150) 
        };
        
        resolve();
      };
      
      img.onerror = () => reject(new Error('Failed to load GIF preview'));
    });

    // Load frames for advanced operations
    try {
      await loadGifFrames(file);
    } catch (error) {
      console.warn('Could not load individual frames:', error);
    }
  }

  async function loadGifFrames(file) {
    try {
      // Check if gifuct is available
      if (typeof gifuct === 'undefined') {
        console.log('gifuct library not available, using fallback');
        throw new Error('Library not loaded');
      }
      
      const arrayBuffer = await file.arrayBuffer();
      const gif = gifuct.parseGIF(arrayBuffer);
      const frames = gifuct.decompressFrames(gif, true);
      
      currentFrames = frames.map((frame, index) => ({
        imageData: frame.patch || frame.pixels,
        width: frame.dims.width,
        height: frame.dims.height,
        delay: frame.delay,
        index: index,
        canvas: createCanvasFromFrame(frame, gif.lsd.width, gif.lsd.height)
      }));
      
      console.log(`Loaded ${currentFrames.length} frames from GIF`);
      return currentFrames;
    } catch (error) {
      console.warn('Could not parse GIF frames, using single frame fallback:', error);
      // Enhanced fallback: create a single frame from the GIF image
      const canvas = await createCanvasFromImage(file);
      currentFrames = [{ 
        index: 0, 
        delay: 100,
        width: canvas.width,
        height: canvas.height,
        canvas: canvas
      }];
      console.log(`Fallback: Created 1 frame from GIF`);
      return currentFrames;
    }
  }

  function createCanvasFromFrame(frame, gifWidth, gifHeight) {
    const canvas = document.createElement('canvas');
    canvas.width = gifWidth;
    canvas.height = gifHeight;
    const ctx = canvas.getContext('2d');
    
    if (frame.patch) {
      const imageData = new ImageData(frame.patch, frame.dims.width, frame.dims.height);
      ctx.putImageData(imageData, frame.dims.left, frame.dims.top);
    }
    
    return canvas;
  }

  async function createCanvasFromImage(file) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    return new Promise((resolve) => {
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        resolve(canvas);
      };
      img.src = URL.createObjectURL(file);
    });
  }

  function handleImageFiles(files) {
    uploadedImages = Array.from(files);
    renderImagePreview();
  }

  function renderImagePreview() {
    const grid = document.getElementById('image-preview-grid');
    grid.style.display = 'block';
    grid.innerHTML = '';

    uploadedImages.forEach((file, index) => {
      const item = document.createElement('div');
      item.className = 'frame-item';
      
      const img = document.createElement('img');
      img.src = URL.createObjectURL(file);
      img.style.maxWidth = '100px';
      img.style.maxHeight = '100px';
      
      const number = document.createElement('div');
      number.className = 'frame-number';
      number.textContent = `Image ${index + 1}`;
      
      item.appendChild(img);
      item.appendChild(number);
      grid.appendChild(item);
    });
  }

  function renderFrameGrid() {
    const grid = document.getElementById('frame-grid');
    grid.innerHTML = '';

    if (currentFrames.length === 0) {
      grid.innerHTML = '<p style="text-align: center; color: #666;">No frames loaded. Please upload a GIF first.</p>';
      return;
    }

    currentFrames.forEach((frame, index) => {
      const item = document.createElement('div');
      item.className = `frame-item ${selectedFrames.has(index) ? 'selected' : ''}`;
      item.onclick = () => toggleFrameSelection(index);
      
      // Create thumbnail from frame canvas
      const thumbnail = document.createElement('canvas');
      thumbnail.width = 80;
      thumbnail.height = 60;
      const thumbCtx = thumbnail.getContext('2d');
      
      if (frame.canvas) {
        thumbCtx.drawImage(frame.canvas, 0, 0, 80, 60);
      } else {
        thumbCtx.fillStyle = `hsl(${index * 36}, 70%, 80%)`;
        thumbCtx.fillRect(0, 0, 80, 60);
        thumbCtx.fillStyle = '#333';
        thumbCtx.font = '12px Arial';
        thumbCtx.textAlign = 'center';
        thumbCtx.fillText(`Frame ${index + 1}`, 40, 35);
      }
      
      thumbnail.style.borderRadius = '0.3em';
      thumbnail.style.border = '1px solid #ddd';
      
      const number = document.createElement('div');
      number.className = 'frame-number';
      number.textContent = `${index + 1}`;
      
      const delay = document.createElement('div');
      delay.style.fontSize = '0.7em';
      delay.style.color = '#888';
      delay.textContent = `${frame.delay || 100}ms`;
      
      item.appendChild(thumbnail);
      item.appendChild(number);
      item.appendChild(delay);
      grid.appendChild(item);
    });
  }

  function toggleFrameSelection(index) {
    if (selectedFrames.has(index)) {
      selectedFrames.delete(index);
    } else {
      selectedFrames.add(index);
    }
    updateFrameSelection();
  }

  function updateFrameSelection() {
    document.querySelectorAll('.frame-item').forEach((item, index) => {
      item.classList.toggle('selected', selectedFrames.has(index));
    });
  }

  function setupCropCanvas() {
    const canvas = document.getElementById('crop-canvas');
    const ctx = canvas.getContext('2d');
    
    if (!currentGif) return;

    const img = new Image();
    img.onload = () => {
      // Set canvas size proportional to image
      const maxWidth = 400;
      const maxHeight = 300;
      const scale = Math.min(maxWidth / img.width, maxHeight / img.height, 1);
      
      canvas.width = img.width * scale;
      canvas.height = img.height * scale;
      
      // Draw actual GIF
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      
      // Draw crop selection
      drawCropSelection(ctx);
      
      // Add mouse interaction
      setupCropInteraction(canvas);
    };
    
    img.src = URL.createObjectURL(currentGif);
  }

  function drawCropSelection(ctx) {
    const { x, y, width, height } = cropSelection;
    
    ctx.strokeStyle = '#D9534F';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.strokeRect(x, y, width, height);
    ctx.setLineDash([]);
  }

  function setupCropInteraction(canvas) {
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };

    canvas.onmousedown = (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      if (isInsideCropArea(x, y)) {
        isDragging = true;
        dragStart = { x: x - cropSelection.x, y: y - cropSelection.y };
      }
    };

    canvas.onmousemove = (e) => {
      if (!isDragging) return;
      
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      cropSelection.x = Math.max(0, Math.min(canvas.width - cropSelection.width, x - dragStart.x));
      cropSelection.y = Math.max(0, Math.min(canvas.height - cropSelection.height, y - dragStart.y));
      
      updateCropInputs();
      setupCropCanvas(); // Redraw
    };

    canvas.onmouseup = () => {
      isDragging = false;
    };
  }

  function isInsideCropArea(x, y) {
    return x >= cropSelection.x && x <= cropSelection.x + cropSelection.width &&
           y >= cropSelection.y && y <= cropSelection.y + cropSelection.height;
  }

  function updateCropInputs() {
    document.getElementById('crop-x').value = Math.round(cropSelection.x);
    document.getElementById('crop-y').value = Math.round(cropSelection.y);
    document.getElementById('crop-width').value = Math.round(cropSelection.width);
    document.getElementById('crop-height').value = Math.round(cropSelection.height);
  }

  function updateCropFromInputs() {
    cropSelection.x = parseInt(document.getElementById('crop-x').value) || 0;
    cropSelection.y = parseInt(document.getElementById('crop-y').value) || 0;
    cropSelection.width = parseInt(document.getElementById('crop-width').value) || 100;
    cropSelection.height = parseInt(document.getElementById('crop-height').value) || 100;
    setupCropCanvas();
  }

  async function processGif() {
    if (isProcessing) return;
    if (!currentGif && uploadedImages.length === 0) {
      showError('Please upload a GIF or images first.');
      return;
    }

    isProcessing = true;
    showLoading();

    try {
      const activeTool = document.querySelector('.tool-tab.active').dataset.tool;
      let result;

      switch (activeTool) {
        case 'resize':
          result = await processResize();
          break;
        case 'effects':
          result = await processEffects();
          break;
        case 'frames':
          result = await processFrames();
          break;
        case 'create':
          result = await processCreate();
          break;
        case 'optimize':
          result = await processOptimize();
          break;
        case 'crop':
          result = await processCrop();
          break;
        default:
          result = currentGif;
      }

      displayResults(result);
      showSuccess('GIF processed successfully!');
    } catch (error) {
      showError('Processing failed: ' + error.message);
    } finally {
      isProcessing = false;
      hideLoading();
    }
  }

  async function processResize() {
    const width = parseInt(document.getElementById('resize-width').value);
    const height = parseInt(document.getElementById('resize-height').value);
    const maintainAspect = document.getElementById('maintain-aspect').checked;
    
    if (!width && !height) {
      throw new Error('Please specify at least width or height');
    }
    
    return await resizeGifOnCanvas(currentGif, width, height, maintainAspect);
  }

  async function processEffects() {
    const effect = document.getElementById('effect-type').value;
    
    if (effect === 'none') return currentGif;
    
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    return new Promise((resolve, reject) => {
      img.onload = async () => {
        canvas.width = img.width;
        canvas.height = img.height;
        
        // Apply the effect
        switch (effect) {
          case 'reverse':
            resolve(await reverseGif(currentGif));
            break;
          case 'speed':
            const speed = parseFloat(document.getElementById('speed-slider').value);
            resolve(await changeGifSpeed(currentGif, speed));
            break;
          case 'brightness':
            const brightness = parseInt(document.getElementById('brightness-slider').value);
            resolve(await adjustBrightness(currentGif, brightness));
            break;
          case 'contrast':
            const contrast = parseInt(document.getElementById('contrast-slider').value);
            resolve(await adjustContrast(currentGif, contrast));
            break;
          case 'rotate':
            const angle = parseInt(document.getElementById('rotate-slider').value);
            resolve(await rotateGif(currentGif, angle));
            break;
          case 'flip':
            const horizontal = document.getElementById('flip-horizontal').checked;
            const vertical = document.getElementById('flip-vertical').checked;
            resolve(await flipGif(currentGif, horizontal, vertical));
            break;
          case 'grayscale':
            resolve(await applyGrayscale(currentGif));
            break;
          case 'sepia':
            resolve(await applySepia(currentGif));
            break;
          default:
            resolve(currentGif);
        }
      };
      
      img.onerror = () => reject(new Error('Failed to load GIF for effects'));
      img.src = URL.createObjectURL(currentGif);
    });
  }

  async function processFrames() {
    const action = document.getElementById('frame-action').value;
    
    switch (action) {
      case 'extract':
        return await extractRealFrames();
      case 'select':
        return await createGifFromSelectedFrames();
      case 'delete':
        return await deleteSelectedFrames();
      case 'duplicate':
        return await duplicateSelectedFrames();
      case 'reorder':
        return await reorderFrames();
      default:
        return currentGif;
    }
  }

  async function processCreate() {
    if (uploadedImages.length === 0) {
      throw new Error('No images selected for GIF creation');
    }
    
    const delay = parseInt(document.getElementById('frame-delay').value);
    const loops = parseInt(document.getElementById('loop-count').value);
    
    return await createGifFromImages(uploadedImages, delay, loops);
  }

  async function processOptimize() {
    const quality = parseInt(document.getElementById('quality-slider').value);
    const colors = parseInt(document.getElementById('colors-slider').value);
    const dither = document.getElementById('dither').checked;
    const optimizeFrames = document.getElementById('optimize-frames').checked;
    const removeDuplicates = document.getElementById('remove-duplicates').checked;
    
    return await optimizeGif(currentGif, {
      quality,
      colors,
      dither,
      optimizeFrames,
      removeDuplicates
    });
  }

  async function processCrop() {
    return await cropGif(currentGif, cropSelection);
  }

  async function extractFramesToZip() {
    // Simulate frame extraction
    const zip = new JSZip();
    
    for (let i = 0; i < 5; i++) {
      const canvas = document.createElement('canvas');
      canvas.width = 100;
      canvas.height = 100;
      const ctx = canvas.getContext('2d');
      
      ctx.fillStyle = `hsl(${i * 72}, 70%, 60%)`;
      ctx.fillRect(0, 0, 100, 100);
      ctx.fillStyle = 'white';
      ctx.font = '20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(`${i + 1}`, 50, 55);
      
      const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
      zip.file(`frame_${i + 1}.png`, blob);
    }
    
    return await zip.generateAsync({ type: 'blob' });
  }

  // Real GIF processing functions
  async function resizeGifOnCanvas(gifFile, targetWidth, targetHeight, maintainAspect) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    return new Promise((resolve, reject) => {
      img.onload = () => {
        let newWidth = targetWidth || img.width;
        let newHeight = targetHeight || img.height;
        
        if (maintainAspect && targetWidth && targetHeight) {
          const aspectRatio = img.width / img.height;
          if (targetWidth / targetHeight > aspectRatio) {
            newWidth = targetHeight * aspectRatio;
          } else {
            newHeight = targetWidth / aspectRatio;
          }
        } else if (maintainAspect && targetWidth && !targetHeight) {
          newHeight = targetWidth / (img.width / img.height);
        } else if (maintainAspect && !targetWidth && targetHeight) {
          newWidth = targetHeight * (img.width / img.height);
        }
        
        canvas.width = newWidth;
        canvas.height = newHeight;
        
        ctx.drawImage(img, 0, 0, newWidth, newHeight);
        
        canvas.toBlob(resolve, 'image/gif', 0.9);
      };
      
      img.onerror = () => reject(new Error('Failed to load GIF for resizing'));
      img.src = URL.createObjectURL(gifFile);
    });
  }

  async function reverseGif(gifFile) {
    if (currentFrames.length <= 1) {
      showMessage('Cannot reverse: GIF has only one frame', 'warning');
      return gifFile;
    }

    showProgressWithAnimation('Reversing animation frames...', currentFrames.length);
    
    // Reverse the frame order
    const reversedFrames = [...currentFrames].reverse();
    
    // Create new GIF with gif.js
    const gif = new GIF({
      workers: 2,
      quality: 10,
      width: reversedFrames[0].canvas.width,
      height: reversedFrames[0].canvas.height
    });

    // Add frames in reverse order
    for (let i = 0; i < reversedFrames.length; i++) {
      const frame = reversedFrames[i];
      gif.addFrame(frame.canvas, { delay: frame.delay || 100 });
      updateProgressAnimation(i + 1, reversedFrames.length, 'Reversing');
      await new Promise(resolve => setTimeout(resolve, 50)); // Visual delay
    }

    return new Promise((resolve) => {
      gif.on('finished', (blob) => {
        hideProgressAnimation();
        resolve(blob);
      });
      gif.render();
    });
  }

  async function changeGifSpeed(gifFile, speedMultiplier) {
    if (currentFrames.length <= 1) {
      showMessage('Cannot change speed: GIF has only one frame', 'warning');
      return gifFile;
    }

    if (speedMultiplier <= 0) {
      throw new Error('Speed multiplier must be greater than 0');
    }

    showProgressWithAnimation(`Adjusting speed to ${speedMultiplier}x...`, currentFrames.length);

    // Create new GIF with adjusted delays
    const gif = new GIF({
      workers: 2,
      quality: 10,
      width: currentFrames[0].canvas.width,
      height: currentFrames[0].canvas.height
    });

    // Adjust frame delays (divide by speed multiplier)
    for (let i = 0; i < currentFrames.length; i++) {
      const frame = currentFrames[i];
      const newDelay = Math.max(10, Math.round((frame.delay || 100) / speedMultiplier));
      gif.addFrame(frame.canvas, { delay: newDelay });
      updateProgressAnimation(i + 1, currentFrames.length, 'Speed Adjusting');
      await new Promise(resolve => setTimeout(resolve, 30));
    }

    return new Promise((resolve) => {
      gif.on('finished', (blob) => {
        hideProgressAnimation();
        resolve(blob);
      });
      gif.render();
    });
  }

  async function adjustBrightness(gifFile, brightness) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    return new Promise((resolve, reject) => {
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        
        ctx.filter = `brightness(${100 + brightness}%)`;
        ctx.drawImage(img, 0, 0);
        
        canvas.toBlob(resolve, 'image/gif', 0.9);
      };
      
      img.onerror = () => reject(new Error('Failed to load GIF for brightness adjustment'));
      img.src = URL.createObjectURL(gifFile);
    });
  }

  async function adjustContrast(gifFile, contrast) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    return new Promise((resolve, reject) => {
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        
        ctx.filter = `contrast(${100 + contrast}%)`;
        ctx.drawImage(img, 0, 0);
        
        canvas.toBlob(resolve, 'image/gif', 0.9);
      };
      
      img.onerror = () => reject(new Error('Failed to load GIF for contrast adjustment'));
      img.src = URL.createObjectURL(gifFile);
    });
  }

  async function rotateGif(gifFile, angle) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    return new Promise((resolve, reject) => {
      img.onload = () => {
        const rad = (angle * Math.PI) / 180;
        const sin = Math.abs(Math.sin(rad));
        const cos = Math.abs(Math.cos(rad));
        
        canvas.width = img.width * cos + img.height * sin;
        canvas.height = img.width * sin + img.height * cos;
        
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(rad);
        ctx.drawImage(img, -img.width / 2, -img.height / 2);
        
        canvas.toBlob(resolve, 'image/gif', 0.9);
      };
      
      img.onerror = () => reject(new Error('Failed to load GIF for rotation'));
      img.src = URL.createObjectURL(gifFile);
    });
  }

  async function flipGif(gifFile, horizontal, vertical) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    return new Promise((resolve, reject) => {
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        
        ctx.scale(horizontal ? -1 : 1, vertical ? -1 : 1);
        ctx.drawImage(img, 
          horizontal ? -canvas.width : 0, 
          vertical ? -canvas.height : 0
        );
        
        canvas.toBlob(resolve, 'image/gif', 0.9);
      };
      
      img.onerror = () => reject(new Error('Failed to load GIF for flipping'));
      img.src = URL.createObjectURL(gifFile);
    });
  }

  async function applyGrayscale(gifFile) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    return new Promise((resolve, reject) => {
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        
        ctx.filter = 'grayscale(100%)';
        ctx.drawImage(img, 0, 0);
        
        canvas.toBlob(resolve, 'image/gif', 0.9);
      };
      
      img.onerror = () => reject(new Error('Failed to load GIF for grayscale'));
      img.src = URL.createObjectURL(gifFile);
    });
  }

  async function applySepia(gifFile) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    return new Promise((resolve, reject) => {
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        
        ctx.filter = 'sepia(100%)';
        ctx.drawImage(img, 0, 0);
        
        canvas.toBlob(resolve, 'image/gif', 0.9);
      };
      
      img.onerror = () => reject(new Error('Failed to load GIF for sepia'));
      img.src = URL.createObjectURL(gifFile);
    });
  }

  async function extractRealFrames() {
    if (currentFrames.length === 0) {
      throw new Error('No frames to extract. Please upload a GIF first.');
    }

    showProgressWithAnimation('Extracting frames...', currentFrames.length);
    
    const zip = new JSZip();
    
    for (let i = 0; i < currentFrames.length; i++) {
      const frame = currentFrames[i];
      
      // Update progress with creative animation
      updateProgressAnimation(i + 1, currentFrames.length, 'Extracting');
      
      // Convert frame to blob
      const blob = await new Promise((resolve) => {
        if (frame.canvas) {
          frame.canvas.toBlob(resolve, 'image/png');
        } else {
          // Fallback: create a placeholder
          const canvas = document.createElement('canvas');
          canvas.width = 200;
          canvas.height = 150;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = `hsl(${i * 36}, 70%, 80%)`;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = '#333';
          ctx.font = '20px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(`Frame ${i + 1}`, canvas.width/2, canvas.height/2);
          canvas.toBlob(resolve, 'image/png');
        }
      });
      
      // Add frame to zip with proper naming
      const frameNumber = String(i + 1).padStart(3, '0');
      const delay = frame.delay || 100;
      zip.file(`frame_${frameNumber}_delay_${delay}ms.png`, blob);
      
      // Add small delay for visual effect
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    hideProgressAnimation();
    
    return await zip.generateAsync({ 
      type: 'blob',
      compression: 'DEFLATE',
      compressionOptions: { level: 6 }
    });
  }

  async function createGifFromSelectedFrames() {
    if (selectedFrames.size === 0) {
      throw new Error('No frames selected. Please select frames first.');
    }

    const selectedFrameArray = Array.from(selectedFrames).sort((a, b) => a - b);
    showProgressWithAnimation('Creating GIF from selected frames...', selectedFrameArray.length);

    const gif = new GIF({
      workers: 2,
      quality: 10,
      width: currentFrames[0].canvas.width,
      height: currentFrames[0].canvas.height
    });

    for (let i = 0; i < selectedFrameArray.length; i++) {
      const frameIndex = selectedFrameArray[i];
      const frame = currentFrames[frameIndex];
      gif.addFrame(frame.canvas, { delay: frame.delay || 100 });
      updateProgressAnimation(i + 1, selectedFrameArray.length, 'Creating GIF');
      await new Promise(resolve => setTimeout(resolve, 50));
    }

    return new Promise((resolve) => {
      gif.on('finished', (blob) => {
        hideProgressAnimation();
        resolve(blob);
      });
      gif.render();
    });
  }

  async function deleteSelectedFrames() {
    if (selectedFrames.size === 0) {
      throw new Error('No frames selected for deletion.');
    }
    
    if (selectedFrames.size >= currentFrames.length) {
      throw new Error('Cannot delete all frames. At least one frame must remain.');
    }

    showProgressWithAnimation('Deleting selected frames...', currentFrames.length);

    // Create new frames array without selected frames
    const newFrames = currentFrames.filter((_, index) => !selectedFrames.has(index));
    
    const gif = new GIF({
      workers: 2,
      quality: 10,
      width: newFrames[0].canvas.width,
      height: newFrames[0].canvas.height
    });

    for (let i = 0; i < newFrames.length; i++) {
      const frame = newFrames[i];
      gif.addFrame(frame.canvas, { delay: frame.delay || 100 });
      updateProgressAnimation(i + 1, newFrames.length, 'Rebuilding GIF');
      await new Promise(resolve => setTimeout(resolve, 50));
    }

    // Update current frames and clear selection
    currentFrames = newFrames;
    selectedFrames.clear();

    return new Promise((resolve) => {
      gif.on('finished', (blob) => {
        hideProgressAnimation();
        resolve(blob);
      });
      gif.render();
    });
  }

  async function duplicateSelectedFrames() {
    if (selectedFrames.size === 0) {
      throw new Error('No frames selected for duplication.');
    }

    showProgressWithAnimation('Duplicating selected frames...', currentFrames.length + selectedFrames.size);

    const newFrames = [];
    
    // Rebuild frames array with duplicates
    for (let i = 0; i < currentFrames.length; i++) {
      newFrames.push(currentFrames[i]);
      if (selectedFrames.has(i)) {
        // Duplicate this frame
        newFrames.push({...currentFrames[i]});
      }
    }

    const gif = new GIF({
      workers: 2,
      quality: 10,
      width: newFrames[0].canvas.width,
      height: newFrames[0].canvas.height
    });

    for (let i = 0; i < newFrames.length; i++) {
      const frame = newFrames[i];
      gif.addFrame(frame.canvas, { delay: frame.delay || 100 });
      updateProgressAnimation(i + 1, newFrames.length, 'Duplicating');
      await new Promise(resolve => setTimeout(resolve, 30));
    }

    currentFrames = newFrames;
    selectedFrames.clear();

    return new Promise((resolve) => {
      gif.on('finished', (blob) => {
        hideProgressAnimation();
        resolve(blob);
      });
      gif.render();
    });
  }

  async function reorderFrames() {
    if (selectedFrames.size < 2) {
      throw new Error('Select at least 2 frames to reorder.');
    }

    showProgressWithAnimation('Reordering frames...', currentFrames.length);

    // Simple reorder: move selected frames to the beginning
    const selectedArray = Array.from(selectedFrames).sort((a, b) => a - b);
    const selectedFrameData = selectedArray.map(i => currentFrames[i]);
    const remainingFrames = currentFrames.filter((_, i) => !selectedFrames.has(i));
    
    const reorderedFrames = [...selectedFrameData, ...remainingFrames];

    const gif = new GIF({
      workers: 2,
      quality: 10,
      width: reorderedFrames[0].canvas.width,
      height: reorderedFrames[0].canvas.height
    });

    for (let i = 0; i < reorderedFrames.length; i++) {
      const frame = reorderedFrames[i];
      gif.addFrame(frame.canvas, { delay: frame.delay || 100 });
      updateProgressAnimation(i + 1, reorderedFrames.length, 'Reordering');
      await new Promise(resolve => setTimeout(resolve, 50));
    }

    currentFrames = reorderedFrames;
    selectedFrames.clear();

    return new Promise((resolve) => {
      gif.on('finished', (blob) => {
        hideProgressAnimation();
        resolve(blob);
      });
      gif.render();
    });
  }

  async function createGifFromImages(images, delay, loops) {
    if (images.length === 0) {
      throw new Error('No images provided');
    }

    showProgressWithAnimation('Creating GIF from images...', images.length);

    // Load all images first
    const loadedImages = [];
    for (let i = 0; i < images.length; i++) {
      const img = new Image();
      const loadPromise = new Promise((resolve, reject) => {
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error(`Failed to load image ${i + 1}`));
      });
      img.src = URL.createObjectURL(images[i]);
      loadedImages.push(await loadPromise);
      updateProgressAnimation(i + 1, images.length, 'Loading Images');
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    // Find common dimensions (use first image as base)
    const baseWidth = loadedImages[0].width;
    const baseHeight = loadedImages[0].height;

    const gif = new GIF({
      workers: 2,
      quality: 10,
      width: baseWidth,
      height: baseHeight,
      repeat: loops === 0 ? 0 : loops - 1 // gif.js uses 0 for infinite, n-1 for n loops
    });

    // Add each image as a frame
    for (let i = 0; i < loadedImages.length; i++) {
      const img = loadedImages[i];
      const canvas = document.createElement('canvas');
      canvas.width = baseWidth;
      canvas.height = baseHeight;
      const ctx = canvas.getContext('2d');
      
      // Draw image scaled to fit
      ctx.drawImage(img, 0, 0, baseWidth, baseHeight);
      
      gif.addFrame(canvas, { delay: delay });
      updateProgressAnimation(i + 1, loadedImages.length, 'Creating Animation');
      await new Promise(resolve => setTimeout(resolve, 50));
    }

    return new Promise((resolve, reject) => {
      gif.on('finished', (blob) => {
        hideProgressAnimation();
        resolve(blob);
      });
      
      gif.on('progress', (progress) => {
        // Additional progress feedback
        updateProgressAnimation(Math.round(progress * 100), 100, 'Encoding GIF');
      });
      
      gif.render();
    });
  }

  async function optimizeGif(gifFile, options) {
    const { quality, colors, dither, optimizeFrames, removeDuplicates } = options;
    
    if (currentFrames.length === 0) {
      throw new Error('No frames loaded for optimization');
    }

    showProgressWithAnimation('Optimizing GIF...', currentFrames.length);

    let framesToProcess = [...currentFrames];

    // Remove duplicate frames if requested
    if (removeDuplicates) {
      framesToProcess = removeDuplicateFrames(framesToProcess);
      updateProgressAnimation(10, 100, 'Removing Duplicates');
      await new Promise(resolve => setTimeout(resolve, 200));
    }

    // Create optimized GIF
    const gif = new GIF({
      workers: 2,
      quality: Math.round((100 - quality) / 10), // gif.js quality is inverted (lower = better)
      width: framesToProcess[0].canvas.width,
      height: framesToProcess[0].canvas.height,
      dither: dither
    });

    // Add frames with optimization
    for (let i = 0; i < framesToProcess.length; i++) {
      const frame = framesToProcess[i];
      
      if (optimizeFrames) {
        // Optimize individual frame
        const optimizedCanvas = await optimizeFrameCanvas(frame.canvas, colors);
        gif.addFrame(optimizedCanvas, { delay: frame.delay || 100 });
      } else {
        gif.addFrame(frame.canvas, { delay: frame.delay || 100 });
      }
      
      updateProgressAnimation(i + 1, framesToProcess.length, 'Optimizing Frames');
      await new Promise(resolve => setTimeout(resolve, 50));
    }

    return new Promise((resolve) => {
      gif.on('finished', (blob) => {
        hideProgressAnimation();
        const compressionRatio = ((gifFile.size - blob.size) / gifFile.size * 100).toFixed(1);
        showMessage(`GIF optimized! Size reduced by ${compressionRatio}%`, 'success');
        resolve(blob);
      });
      gif.render();
    });
  }

  function removeDuplicateFrames(frames) {
    const uniqueFrames = [];
    const seen = new Set();

    for (const frame of frames) {
      // Create a simple hash of the frame (not perfect, but functional)
      const canvas = frame.canvas;
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      
      // Sample pixels for comparison (every 10th pixel for performance)
      let hash = '';
      for (let i = 0; i < imageData.data.length; i += 40) {
        hash += imageData.data[i];
      }

      if (!seen.has(hash)) {
        seen.add(hash);
        uniqueFrames.push(frame);
      }
    }

    return uniqueFrames;
  }

  async function optimizeFrameCanvas(canvas, maxColors) {
    // Color quantization simulation
    const optimizedCanvas = document.createElement('canvas');
    optimizedCanvas.width = canvas.width;
    optimizedCanvas.height = canvas.height;
    const ctx = optimizedCanvas.getContext('2d');
    
    ctx.drawImage(canvas, 0, 0);
    
    if (maxColors < 256) {
      // Simple color reduction by posterizing
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      
      const levels = Math.ceil(256 / (256 / maxColors));
      
      for (let i = 0; i < data.length; i += 4) {
        data[i] = Math.round(data[i] / levels) * levels;     // Red
        data[i + 1] = Math.round(data[i + 1] / levels) * levels; // Green
        data[i + 2] = Math.round(data[i + 2] / levels) * levels; // Blue
      }
      
      ctx.putImageData(imageData, 0, 0);
    }
    
    return optimizedCanvas;
  }

  async function cropGif(gifFile, selection) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    return new Promise((resolve, reject) => {
      img.onload = () => {
        canvas.width = selection.width;
        canvas.height = selection.height;
        
        ctx.drawImage(img, 
          selection.x, selection.y, selection.width, selection.height,
          0, 0, selection.width, selection.height
        );
        
        canvas.toBlob((blob) => {
          showMessage(`GIF cropped to ${selection.width}x${selection.height}`, 'success');
          resolve(blob);
        }, 'image/gif', 0.9);
      };
      
      img.onerror = () => reject(new Error('Failed to crop GIF'));
      img.src = URL.createObjectURL(gifFile);
    });
  }

  function displayResults(result) {
    const resultSection = document.getElementById('result-section');
    const resultGrid = document.getElementById('result-grid');
    const previewComparison = document.getElementById('preview-comparison');
    const downloadSection = document.getElementById('download-section');

    // Show file information
    resultGrid.innerHTML = `
      <div class="result-card">
        <h4>📊 Original Size</h4>
        <div class="value">${(currentGif?.size / 1024).toFixed(1) || 'N/A'} KB</div>
      </div>
      <div class="result-card">
        <h4>📊 Processed Size</h4>
        <div class="value">${(result.size / 1024).toFixed(1)} KB</div>
      </div>
      <div class="result-card">
        <h4>💾 Size Change</h4>
        <div class="value ${result.size < (currentGif?.size || 0) ? 'size-success' : 'size-warning'}">
          ${currentGif ? ((result.size - currentGif.size) / currentGif.size * 100).toFixed(1) : '0'}%
        </div>
      </div>
    `;

    // Show preview comparison
    if (currentGif) {
      previewComparison.innerHTML = `
        <h4>🔍 Before & After Comparison</h4>
        <div class="preview-images">
          <div class="preview-container">
            <h5>Original</h5>
            <img src="${URL.createObjectURL(currentGif)}" alt="Original GIF" class="preview-image">
          </div>
          <div class="preview-container">
            <h5>Processed</h5>
            <img src="${URL.createObjectURL(result)}" alt="Processed GIF" class="preview-image">
          </div>
        </div>
      `;
    }

    // Create download button
    const downloadBtn = document.createElement('a');
    downloadBtn.href = URL.createObjectURL(result);
    downloadBtn.download = getDownloadFilename(result);
    downloadBtn.className = 'download-btn';
    downloadBtn.textContent = '⬇️ Download Result';
    
    downloadSection.innerHTML = `
      <div style="margin-bottom: 1em;">
        <div style="font-size: 1.5em; margin-bottom: 0.5em;">✅</div>
        <div style="font-weight: 600; color: #228B22;">Processing Complete!</div>
        <div style="color: #666; margin-top: 0.5em;">Your GIF is ready for download.</div>
      </div>
    `;
    downloadSection.appendChild(downloadBtn);

    resultSection.style.display = 'block';
  }

  function getDownloadFilename(result) {
    const activeTool = document.querySelector('.tool-tab.active').dataset.tool;
    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
    
    if (result.type.includes('zip')) {
      return `gif-frames-${timestamp}.zip`;
    }
    
    return `processed-${activeTool}-${timestamp}.gif`;
  }

  function showProgress() {
    const progress = document.getElementById('upload-progress');
    const fill = document.getElementById('progress-fill');
    const text = document.getElementById('progress-text');
    
    progress.style.display = 'block';
    
    let percent = 0;
    const interval = setInterval(() => {
      percent = Math.min(100, percent + Math.random() * 10);
      fill.style.width = `${percent}%`;
      text.textContent = `Loading: ${Math.round(percent)}%`;
      
      if (percent >= 100) {
        clearInterval(interval);
        setTimeout(() => {
          progress.style.display = 'none';
        }, 500);
      }
    }, 100);
  }

  function hideProgress() {
    document.getElementById('upload-progress').style.display = 'none';
  }

  function showLoading() {
    document.getElementById('loading-animation').style.display = 'block';
  }

  function hideLoading() {
    document.getElementById('loading-animation').style.display = 'none';
  }

  function showError(message) {
    showMessage(message, 'error');
  }

  function showSuccess(message) {
    showMessage(message, 'success');
  }

  function showMessage(message, type) {
    const existing = document.querySelector('.temporary-message');
    if (existing) existing.remove();

    const msg = document.createElement('div');
    msg.className = `${type}-message temporary-message`;
    msg.textContent = message;
    
    const container = document.querySelector('.reduce-size-container');
    container.insertBefore(msg, container.firstElementChild.nextElementSibling);
    
    setTimeout(() => msg.remove(), 5000);
  }

  // Creative progress animation functions
  function showProgressWithAnimation(message, totalSteps) {
    const progressContainer = document.getElementById('upload-progress');
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');
    
    progressContainer.style.display = 'block';
    progressFill.style.width = '0%';
    progressText.innerHTML = `
      <div style="display: flex; align-items: center; justify-content: center; gap: 0.5em;">
        <div class="creative-spinner"></div>
        <span>${message}</span>
        <span class="frame-counter">0/${totalSteps}</span>
      </div>
    `;
    
    // Add spinner animation if not exists
    if (!document.querySelector('.creative-spinner-style')) {
      const style = document.createElement('style');
      style.className = 'creative-spinner-style';
      style.textContent = `
        .creative-spinner {
          width: 20px;
          height: 20px;
          border: 2px solid #f3f3f3;
          border-top: 2px solid #D9534F;
          border-radius: 50%;
          animation: creative-spin 1s linear infinite;
        }
        .frame-counter {
          background: #4682B4;
          color: white;
          padding: 0.2em 0.5em;
          border-radius: 0.3em;
          font-size: 0.8em;
          font-weight: bold;
        }
        @keyframes creative-spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        .progress-pulse {
          animation: progress-pulse 0.5s ease-in-out;
        }
        @keyframes progress-pulse {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.05); }
        }
      `;
      document.head.appendChild(style);
    }
  }

  function updateProgressAnimation(current, total, action) {
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');
    const percent = Math.round((current / total) * 100);
    
    progressFill.style.width = `${percent}%`;
    progressFill.classList.add('progress-pulse');
    
    // Remove pulse class after animation
    setTimeout(() => {
      progressFill.classList.remove('progress-pulse');
    }, 500);
    
    progressText.innerHTML = `
      <div style="display: flex; align-items: center; justify-content: center; gap: 0.5em;">
        <div class="creative-spinner"></div>
        <span>${action}...</span>
        <span class="frame-counter">${current}/${total}</span>
        <span style="font-size: 0.9em;">(${percent}%)</span>
      </div>
    `;
    
    // Add creative visual feedback for milestones
    if (percent === 25 || percent === 50 || percent === 75) {
      progressText.innerHTML += '<span style="margin-left: 0.5em;">🎯</span>';
    }
    
    if (percent === 100) {
      progressText.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; gap: 0.5em;">
          <span style="color: #228B22;">✅</span>
          <span style="color: #228B22; font-weight: bold;">${action} Complete!</span>
          <span class="frame-counter">${current}/${total}</span>
        </div>
      `;
    }
  }

  function hideProgressAnimation() {
    setTimeout(() => {
      document.getElementById('upload-progress').style.display = 'none';
    }, 1000); // Keep visible for a moment to show completion
  }

  // Auto-initialize
  if (document.readyState !== 'loading') {
    setTimeout(init, 50);
  } else {
    document.addEventListener('DOMContentLoaded', () => setTimeout(init, 50));
  }

})();
</script>
</body>
</html>
